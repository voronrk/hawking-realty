# Задание 18

В качестве реализации задания выбрана отправка письма администратору портала при добавлении свойств здания (поскольку остальные таблицы ещё не реализованы).

В файле EventServiceProvider в массив слушателей $listen добавлен слушатель события BuildingPropertyAdded с обработчиком SendEmailAddingpropertyNotification. 

Командой php artisan event:generate сгенерированы классы для слушателя (BuildingPropertyAdded) и обработчика (SendEmailAddingpropertyNotification). В методе handle обработчика реализован вызов класса для отправки письма.

Почтовый класс создан командой php artisan make:mail PropertyAdded. Произведены настройки в файле config\mail.php и .env. В качестве драйвера выбран smpt.

Сделан примитивный шаблон email.blade.php, принимающий в качестве параметра имя добавленного свойства. Конструктор почтового класса принимает имя добавленного свойства и записывает его в публичное свойство класса, делая таким образом доступным для шаблона.

Отправка письма обёрнута в try...catch, и в случае ошибки пишет сообщение уровня error в лог. 

# Задание 17
Скорректируйте реализованную фильтрацию и поиск данных в своем проекте наElasticSearch. Занесите в ElasticSearchминимум одну сущность проекта. 

Пока не реализовано

# Задание 16

Начат курсовой проект. Созданы таблицы для простых постоянных данных: тип квартиры, состояние и материал стен. Созданы ресурсные конторллеры для них, а также api-роуты, отдающие и обновляющие эти данные.

В реализации роутов использованы два подхода. Один - стандартный для Laravel (роуты для wallmaterial) с внедрением модели в параметры запроса. Второй - с передачей параметров через Request (роуты для types и condition; подход слизан с REST API Битрикс24). Прошу дать комментарий по второму подходу.

## Обернуть запросы в базу данных в кэш, используя обычный и тегированный кэши.
Работа с обычным кэшем через драйвер 'file' реализована в контроллере ConditionController. Метод index проверяет наличие в кэше массива данных с тегом 'condition' и в случае нахождения возвращает этот массив. Если данные в кэше отсутствуют, то в него записывается вся коллекция, полученная из модели. Время жизни кэша не ограничено, поскольку эти данные в базе почти никогда не изменяются.

По аналогичному алгоритму реализован метод show, возвращающий одну запись по её id (id передаётся в запросе).
Метод update обновляет значение в модели, id которой передан в запросе, после чего очищает кэш, чтобы при следующем запросе list или get данные брались из базы.

В контроллере TypeController методы реализованы по таким же алгоритмам, только кэш работает через драйвер memcached (отдельной установки для него не потребовалсь, поскольку он входит в поставку OpenServer. Нужно было только раскомментировать строку 'extension = memcached' в конфигурации PHP). Для демонстрации использовался тегированный кэш, хотя практического смысла в данном случае в этом нет. В будущем планируется сделать разнести по тегам кэш для постоянных данных (уже реализованные параметры объектов) и для просмотренных/выбранных квартир.

Для тестов был создан метод cacheClear (и роут под него) для очистки кэша. После создания artisan-команды метод был удалён.

## Написать Artisan-команду, которая периодически очищает кэш.
Реализована команда cache:clear для очистки кэша по ключам (файл ClearCache). В качестве параметров передаётся ключ и драйвер, которые подставляются в команду очистки. Также проверяется наличие переданного ключа в кэше и выводится ошибка, если ключ не найден.

По-хорошему здесь нужно сделать параметр 'driver' необязательным и работать с кэшем по умолчанию в случае его отсутствия. Параметр 'key' тоже можно сделать необязательным и при его отсутствии очищать весь кэш. Также нужно добавить работу с тегированным кэшем (сейчас команда с ним не работает). 